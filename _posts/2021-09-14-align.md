---
title: align
date: 2021-09-14 14:10:00 +0800
categories: [Blogging]
tags: [writing]
---

今天看到了一个比较神奇的宏定义，关于字节对齐的,转换成比较能理解的语言就如下了。

```c++
#include <iostream>

using namespace std;

// x 对 a 对齐，先 + ，之后利用低位取0

int align(int x,int a){
    int add = (x + a - 1); // 类似于ceiling的操作，(x + a - 1) / a
    int lowzero = ~(a - 1);// 此时，最低位1之后的为全0，之前的最低位1不变
    return (x + a - 1) & (~(a - 1));
}

int main(){
    int x,a;
    cin >> x >> a;
    cout << align(x,a) << endl;
    return 0;
}
```

这里先做一个上取整+,很类似于之前那个ceiling的操作。

```c++
int ceil(int x,int a){
	return (x + a - 1) / a;
}
```

之后的字节对齐就比较显眼了，因为a确定只有一个1，要么32，要么16，要么8，所以让最低位之后的变0，高位全1就ok了.因为之前做了一个上取整的操作，之后得到的数一定是一个a的倍数。


## 结构对齐的规则

结构体内存对齐的规则是比较复杂的，但可以概括为以下几个主要原则：

1. 基本对齐规则：

   - 每个成员变量的起始地址必须是其自身大小的整数倍。
   - 整个结构体的大小必须是其最大成员变量大小的整数倍。

2. 结构体对齐值：
   
   结构体的对齐值是其成员中要求最严格对齐的类型的大小。通常是最大基本类型成员的大小。

3. 成员排列：

   - 第一个成员放在偏移量为0的地方。
   - 后面每个成员的对齐值是该成员大小与结构体对齐值中的较小者。

4. 填充：

   - 如果下一个成员的起始位置不满足其对齐要求，编译器会在当前位置和下一个成员之间插入填充字节。
   - 在结构体的最后，可能会添加填充以使整个结构体的大小是结构体对齐值的整数倍。

5. 嵌套结构体：

   - 嵌套的结构体会按其自身的对齐要求对齐。
   - 包含嵌套结构体的外部结构体可能因此需要额外的填充。

6. 位域（Bit fields）：

   - 位域的对齐规则可能因编译器而异。
   - 通常，包含位域的结构体会按照未使用位域时的规则对齐。

7. 编译器特定行为：

   - 不同编译器可能有轻微不同的对齐策略，特别是在处理位域时。
   - 某些编译器可能会为了优化而重新排序成员（除非明确禁止）。

8. 平台相关性：

   - 对齐规则可能因目标平台（32位/64位）而异。

9. 特殊指令：

   - 可以使用 `#pragma pack` 或 `__attribute__((packed))` 等指令来改变默认对齐行为。

示例：

```cpp
struct Example {
    char a;     // 1 byte
    int b;      // 4 bytes
    short c;    // 2 bytes
    double d;   // 8 bytes
};
```

在大多数64位系统上，这个结构体的内存布局可能是：

```
a: 1 byte
   3 bytes padding
b: 4 bytes
c: 2 bytes
   6 bytes padding
d: 8 bytes
```

总大小为24字节（8的倍数，因为最大成员是8字节的double）。
