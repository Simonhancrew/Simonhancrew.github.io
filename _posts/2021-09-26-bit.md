---
title: 原反补的问题
date: 2021-09-26 14:10:00 +0800
categories: [Blogging]
tags: [writing]
---

leetcode-371题，两整数之和，如果用python做的话是一道理解原反补问题的绝佳例子，py的int还是64位，难度反而更大了。首先放代码

```python
MASK = 4294967296 #2 ** 32
MAXINT = 2147483647 #2 ** 31 - 1
MININT = 2147483648 # 2 ** 31
T32 = 4294967295 #2 ** 32 - 1

# 顺便记录一下32位int的相关东西，最高位1的话是2 ** 31，intmax = 2 ** 31 - 1,intmin = 2 ** 31
# 32位全1的话，2 ** 32 - 1，此时是-1


class Solution:
    def getSum(self, a: int, b: int) -> int:
        while b != 0:
            add,carry = (a ^ b) % MASK,((a & b) << 1) % MASK
            a,b= add,carry
        return a if a <= MAXINT else ~(a ^ (T32))
```

转换成2进制，先求不进位的部分，异或，如果是两个1的话，就代表有进位了，会是一个0

然后求进位的部分，只有两个都是1才进位，所以与了之后左位移就可以了

当然进位是有限的，在c++等里面int都是32位的，自然可以做到简单的mod问题。

py的int是64位的，这里对uint做一个取余，让这个数的范围始终在32位以内

之后，如果是结果是负数的话，还需要额外处理，因为拿到的实际二进制其实是32位的补码，64位下显示是不对的。

首先把a和0xffffffff异或一下，因为32位补码的问题，0的位反而会的得到1。最后结果上二进制是1的位上，刚好是64位补码上为0的位，再次取反就能拿到a的64位补码