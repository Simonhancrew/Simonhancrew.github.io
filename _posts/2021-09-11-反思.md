---
layout: post
title:  "反思"
date:   2021-09-11
---

### Rethink of recent

最近周赛在打卡题之间徘徊，其实还是挺垃圾的，毕竟接触算法已经6个月了。今天acwing的周赛直接击碎内心，直接自闭了。

三题全是打卡题难度，但是就是不能自己完整的调出来，有错误比较难更进一步的分析优化的思路，直接自闭了。

分析了一下，第二题，是一个前缀和的问题，有点组合数的意思，我想的是前缀和 + 后缀和，考虑了long long的问题，最后是TLE的，那个算法复杂度是不行的。正确的解法是枚举切第一刀和第二刀的位置。这里是思路不清晰，逻辑完全没顺序。

```
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10;

typedef long long LL;

// 枚举第一刀和第二刀切在哪里

LL a[N];
int n;

int main()
{
    cin >> n;
    for(int i = 0;i < n;i++) cin >> a[i];
    for(int i = 1;i < n;i++) a[i] += a[i - 1];
    if(n <= 2 || a[n - 1] % 3) cout << 0 << endl;
    else{
        LL cnt = 0,cnt1 = 0,sum = a[n - 1] / 3;
        for(int i = 0;i < n - 1;i++){
            if(a[i] == sum * 2) cnt1 += cnt;    
            if(a[i] == sum) cnt++;
        }
        cout << cnt1 << endl;
    }
    return 0;
}
```



第三题，可以贪心做，也可以用前i位最大最小值枚举山峰山谷，这个我第一眼没思路，还是落入逻辑无序的下乘。但是我的习惯是前面的题没做出来，后面的我也没兴趣做了。所以当作没正常发挥吧。

```
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10;

int a[N];
int n;

// 画图就行了，有序的话是一条直线。

int main(){
    cin >> n;
    for(int i = 0;i < n;i++) cin >> a[i];
    for(int i = 1;i < n - 1;i++){
        if((a[i] < a[0] && a[i] < a[i + 1])|| (a[i] > a[0] && a[i] > a[i + 1])){
            cout << 3 << endl;
            cout << 1 << ' ' << i + 1 << ' ' << i + 2 << endl;
            return 0;
        }
    }
    cout << 0 << endl;
    return 0;
}
```



后续的时间可能上午刷一刷算法竞赛进阶指南和USACO Training，感觉训练量还是少了，习题课的习题也做少了，我总得感觉还是自己训练量不够。

下午就考虑论文的问题，看是写行人检测还是行人属性检测。

