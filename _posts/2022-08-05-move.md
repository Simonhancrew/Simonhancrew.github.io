---
layout: post
title: "move使用指南"
date: 2022-08-05
---

## std::move使用指南

使用move在不实现它两个配套函数，或者配套函数和拷贝构造和拷贝assign的操作是一样的时候。move根本没有意义。

不如看看rust的转移是怎么做的。i32和f64之类的基础变量，默认实现了copy。在很多数据在堆上的的复杂数据结构（我的理解其实就是c++里的对象了），所有权是转移的。

在这个基础上，我去理解move。c++的move仅仅是一个强转，我的理解下，他的意义就是单纯的为了匹配到相应的重载。可以参考CS106L实现的hashmap

真正所有去权的转移，是在配套函数内。比如持有一个char*的string的move函数，持有者应该将char*的所有权转移，并将指针设置空。

其实说到底，还是对与堆上分配的内存的自我管理。
