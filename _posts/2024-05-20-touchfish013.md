---
title: touch fish 13
date: 2024-05-20 12:29:00 +0800
categories: [Blogging, touch-fish]
tags: [writing]
---


### 1. [string sso](https://devblogs.microsoft.com/oldnewthing/20240510-00/?p=109742)

### 2. [手把手asan](https://blog.trailofbits.com/2024/05/16/understanding-addresssanitizer-better-memory-safety-for-your-code/)

### 3. [template多参数怎么拿具体idx](https://devblogs.microsoft.com/oldnewthing/20240516-00/?p=109771)

### 4. [注入模版类名怎么写？](https://devblogs.microsoft.com/oldnewthing/20240517-00/?p=109774)

### 5. [高速缓存与一致性](https://www.zhihu.com/column/cpu-cache)

### 6 简单看几个c++的STL用法

简单看几个c++里STL很有用的地方，然后需要注意的地方

#### 6.1 批量删除

第一个脑回路想到的可能是正向遍历，然后删除。

这样的缺点是会造成后续元素的往前移动，导致时间复杂度为O(n^2)。

```cpp
for (auto it = vec.begin(); it != vec.end();) {
  if (condition) {
    it = vec.erase(it);
  } else {
    ++it;
  }
}
```

当然，如果你倒序遍历，常数会小一些，但是时间复杂度还是O(n^2)。

标准库里提供了一种更好的办法，就是`std::remove_if`。

```cpp
auto cond = [&](const auto& x) { return SomeCondition(x, param); };
vec.erase(std::remove_if(vec.begin(), vec.end(), cond), vec.end());
```

这种情况下的算法复杂度是O(n)。

#### 6.2 使用auto

for range loop，记得用auto，不然的话可能有额外的拷贝

```cpp

map<string, int> word_count;
for (const auto& kv : word_count) {
  // kv.first, kv.second
}

// C++17
for (const auto& [word, count] : word_count} {
}
```

如果一定要标注类型，记得const

```cpp
for (const std::pair<const std::string, int>& kv : word_count) {
}
```
