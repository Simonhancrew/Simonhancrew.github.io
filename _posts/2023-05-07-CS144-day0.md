---
layout: post
title: "CS144-Note1"
date: 2023-05-07
---

## CS144-Lab Note-0

CS144 Code Reading Note， QAQ

### 0. socket地址

通用地址`sockaddr`, sa_data里把ip和port都混在一起，`sockaddr_in`把port和ip分开存。
sa_data一共是14个byte，sockaddr_in中包含sin_port(uint16_t:2 byte),in_addr(实际是一个int：4 byte)， 还有8个char做padding(unused)。sa_family一般是2字节(short int)

```c
struct in_addr{
  In_addr_t s_addr; // actually  int
};
```
另外还需要注意端序的问题，sin_port和sin_addr都必须是网络字节序（NBO），一般可视化的数字都是主机字节序(HBO), 所以不得不提一下`htons()`(host to net, 端口号由主机字节序转换为网络序)和`inet_addr()`

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>

int main() {
  int fd;
  struct sockaddr_in addrs;

  fd = socket(AF_INET,SOCK_STREAM,0);

  bzero(&addrs,sizeof(addrs)); 
  addrs.sin_family = AF_INET; 
  addrs.sin_port = htons(443);
  addrs.sin_addr.s_addr = inet_addr("127.0.0.1");
  printf("%s", inet_ntoa(addrs.sin_addr.s_addr));
  bind(fd,(struct sockaddr *)&addrs,sizeof(struct sockaddr); 
  return 0;
}
```

sockaddr常用于bind、connect、recvfrom、sendto等函数的参数，指明地址信息，是一种通用的套接字地址。

我的理解是sockaddr_in是给人用的，sockaddr是类似于标准


```c

/* POSIX.1g specifies this type name for the `sa_family' member.  */
typedef unsigned short int sa_family_t;

/* This macro is used to declare the initial common members
   of the data types used for socket addresses, `struct sockaddr',
   `struct sockaddr_in', `struct sockaddr_un', etc.  */
#define	__SOCKADDR_COMMON(sa_prefix) \
  sa_family_t sa_prefix##family

// 16 byte
/* Structure describing a generic socket address.  */
struct sockaddr {
  __SOCKADDR_COMMON (sa_);	/* Common data: address family and length.  */
  char sa_data[14];		/* Address data.  */
};

// 128 byte
/* Structure large enough to hold any socket address (with the historical
   exception of AF_UNIX).  */
#define __ss_aligntype	unsigned long int
#define _SS_PADSIZE \ // = 128 - 2 - 4 
  (_SS_SIZE - __SOCKADDR_COMMON_SIZE - sizeof (__ss_aligntype))
struct sockaddr_storage {
  __SOCKADDR_COMMON (ss_);	/* Address family, etc.  */ // 2 
  char __ss_padding[_SS_PADSIZE]; // 126 
  __ss_aligntype __ss_align;	/* Force desired alignment.  */ //4
};

/* Structure describing an Internet socket address.  */
struct sockaddr_in {
  __SOCKADDR_COMMON (sin_);
  in_port_t sin_port;			/* Port number.  */
  struct in_addr sin_addr;		/* Internet address.  */

  /* Pad to size of `struct sockaddr'.  */
  unsigned char sin_zero[sizeof (struct sockaddr) -
        __SOCKADDR_COMMON_SIZE -
        sizeof (in_port_t) -
        sizeof (struct in_addr)];
};


// 28 char
struct sockaddr_in6 {
    sa_family_t sin6_family;    /* AF_INET6 */
    in_port_t sin6_port;        /* Transport layer port # */
    uint32_t sin6_flowinfo;     /* IPv6 flow information */
    struct in6_addr sin6_addr;  /* IPv6 address */
    uint32_t sin6_scope_id;     /* IPv6 scope-id */
};


struct in6_addr {
    union {
        uint8_t u6_addr8[16];
        uint16_t u6_addr16[8];
        uint32_t u6_addr32[4];
    } in6_u; // 16 

    #define s6_addr                 in6_u.u6_addr8
    #define s6_addr16               in6_u.u6_addr16
    #define s6_addr32               in6_u.u6_addr32
};

```


### 1. shutdown and close

看boost的一个库里也这样做了， 先shutdown send， 然后再close，写的是elegant close tcp connection， 优雅在哪里。

大多数情况下，tcp链接都是半关闭的，只有一个方向有传输, 完成操作之后再发一个FIN。

```
int close(int sockfd)
```
当前函数对socket执行close操作，-1失败。执行之后当前sockfd的引用计数--（socket可以被多个进程共享，fork之后引用计数++），变成0的时候就释放了(shared_ptr), 这个时候双向的流都关闭了。

为了关闭两个方向的数据流，在数据接收方向，系统内核会将socket设置为不可读，任何读操作都会返回异常；在数据发送方向，系统内核尝试将发送缓冲区的数据发送给对端，并最后向对端发送一个FIN报文，接下来如果再对socket进行写操作会返回异常。

如果对端没有检测到socket已关闭，仍然继续发送报文，则会收到一个RST报文。如果向这个已经收到RST的socket执行写操作，内核会发出一个SIGPIPE信号给进程，该信号的默认行为是终止进程。

简单来讲，不优雅的关闭就是:
```
1. 你向对端发送了一个FIN，闭嘴了
2. 对面向你发送了ACK，表示对FIN的确认
3. 对端表示服务没结束， 我还要发，然后就发了
4. 你的kernel知道这个socktd直接无了，向对面发送了RST，上层啥都不知道。

tcp的四次挥手没有合理的结束
```

shutdown, 返回值和close同
```
int shutdown(int sockfd, int howto)

hotwo:
  SHUT_RD(0)
  SHUT_WR(1)
  SHUT_RDWR(2)
```

针对不同的howto：

1. SHUT_RD(0)：READ当前fd被关闭，缓冲区数据丢，新的incomming丢(但是会对新来的包做ack)，对该socket进行读操作直接返回 EOF。某种意义上讲，对端不知道数据已经丢了，感觉有点意思。

2. SHUT_WR(1)：Write，此时其实就是半关闭状态了，这个影响是全局的，不管这个fd被fork了多少次，他们都不能写了。缓冲区的数据此时会被完全发送清空， 并且给对面发了一个FIN。再写这个FD是会报错的， 但是ack是不受影响的。总结的说就是这个都是针对应用层的shutdown， 不会影响tcp的可靠传输。

3. SHUT_RDWR(2): 双向关闭 = 1 + 2

shutdown用来关闭应用层链接(所有，半关闭会发FIN)，close拿掉当前应用层的fd(当前进程)，然后去内核看看能不能释放，这也就代表他不一定发了fin。

